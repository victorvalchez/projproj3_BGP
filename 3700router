#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math


class Router:
    relations = {}
    sockets = {}
    ports = {}

    table_disaggregated = {}  # table that contains all the updates, no aggregation applied
    table_aggregation = {}
    ports_original = {}  # dict to identify the IP associated to each port
    #ip_port_original = {}  # dict to identify the port associated to each new IP

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)

        self.asn = asn
        for relationship in connections:
            # Neighbor == IP that ends with .2
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))

            self.ports[neighbor] = int(port)
            # TODO, replace this variable with 'peer' attribute
            self.ports_original[int(port)] = neighbor
            # self.ip_port_original[neighbor] = int(port)

            self.relations[neighbor] = relation
            self.send(neighbor,
                      json.dumps({"type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}}))

            self.table_disaggregated[int(port)] = []
            self.table_aggregation[int(port)] = []

    def our_addr(self, dst):
        """Router IP address, takes the destination and changes the final 2 with a 1"""
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def update(self, msg_dic):
        # -----------
        # Save a copy of the announcement
        # -----------
        # TODO

        # -----------
        # update disaggregated forwarding table
        # -----------
        port = self.ports[msg_dic['src']]  # get the port from which we received the message

        self.table_disaggregated[port].append(msg_dic['msg'])  # add the update with the port as the key
        self.table_disaggregated[port][-1]['peer'] = msg_dic['src']  # add peer information to the entry

        # -----------
        # send copies of the announcement
        # -----------
        self.update_neighbors(msg_dic, "update",  {
                                                    "network": msg_dic['msg']['network'],
                                                    "netmask": msg_dic['msg']['netmask'],
                                                    "ASPath": [self.asn] + msg_dic['msg']['ASPath']
                                                    })

                                                    
        # -----------
        # updated aggregated forwarding table
        # -----------
        self.table_aggregation[port].append(msg_dic['msg'])  # add the update with the port as the key
        self.table_aggregation[port][-1]['peer'] = msg_dic['src']  # add peer information to the entry

        # check if aggregation
        self.check_aggregation(port)


        print("--------------------------------------------------------------")
        print("AGGREG: ",self.table_aggregation)
        print("DISAGGREG: ", self.table_disaggregated)
        print("--------------------------------------------------------------")

        
 

    def check_aggregation(self, port):
        # check if the last added network can be aggregated
        i = 0
        while i < len(self.table_aggregation[port]) - 1:
            network = self.table_aggregation[port][i]
            if self.is_aggregable(port, network):
                #if we had performed aggregation, we must check everything again
                i=0
            else:
                i+=1

    def is_aggregable(self, port, network):
        network2 = self.table_aggregation[port][-1]

        print('network: ', network)
        print('networik2: ', network2)

        if network['localpref'] == network2['localpref']  and network['selfOrigin'] == network2['selfOrigin'] and network['origin'] == network2['origin'] and network['netmask'] == network2['netmask'] :
            print('ha entrado')
            
            #check if the networks coincide
            binary_netmask = self.ip_to_binary(network['netmask'])
            print(binary_netmask)

            long = 31
            while long > 0 and binary_netmask[long] == '0':
                long -= 1

            # now long contains the position of the first '1' of the netwask
            # which is the position of the first bit we don't want to compare

            #convert both networks to binary
            binary_network1 = self.ip_to_binary(network['netmask'])[0:long]
            binary_network2 = self.ip_to_binary(network2['netmask'])[0:long]


            if binary_network1 == binary_network2:
                #Delete the original network (because of aggregation)
                #by keeping the new one at the end, we can run the same algorithm again
                self.table_aggregation[port].remove(network) 

                #update the aggregated entry
                #update netmask
                aux = list(binary_netmask)
                aux[long] = '0'
                binary_netmask = ''.join(aux)
                print(binary_netmask)
                aux = [int(binary_netmask[i:i+8], 2) for i in range(0, 25, 8)]

                self.table_aggregation[port][-1]['netmask'] = "%d.%d.%d.%d" % (aux[0], aux[1], aux[2], aux[3])

                #we don't need to update the network because we are going to apply the mask anyways
                #but looking at the tests given, we have to do it
                #update network
                binary_network = self.ip_to_binary(self.table_aggregation[port][-1]['network'])

                aux = list(binary_network)
                aux[long] = '0'
                binary_network = ''.join(aux)
                print(binary_network)
                aux = [int(binary_network[i:i+8], 2) for i in range(0, 25, 8)]

                self.table_aggregation[port][-1]['network'] = "%d.%d.%d.%d" % (aux[0], aux[1], aux[2], aux[3])

                return True

        return False


    def ip_to_binary(self, ip):
        aux = ip.split('.')
        binary_number = ""
        for i in aux:
            binary = format(int(i), "08b") 
            binary_number += str(binary)
        return binary_number


    def search_port(self, ip):
        port = -1
        ip_split = ip.split('.')

        i = 0
        ports_list = list(self.table_disaggregated.keys())
        flag = False
        while not flag and i < len(ports_list):
            networks_of_port_list = self.table_disaggregated[ports_list[i]]
            j = 0
            while not flag and j < len(networks_of_port_list):
                # apply the mask
                current_netmask = networks_of_port_list[j]['netmask'].split('.')
                dest_masked = [int(ip_split[index]) & int(current_netmask[index]) for index in range(4)]
                src_masked = [int(networks_of_port_list[j]['network'].split('.')[index]) & int(current_netmask[index]) for index in range(4)]
                # compare with the given network
                k = 0
                flag = True
                # Solo dejar la flag aqui y en los demas siempre correrlo, entonces al final coger
                # el que mas largo tenga parecido
                while flag and k < 4:
                    if dest_masked[k] != src_masked[k]:
                        flag = False
                    k += 1

                if flag:
                    port = ports_list[i]

                j += 1
            i += 1

        return port  # -1 if the port is not found

    def search_networks(self, ip):
        """Find destiination IP """
        network_matches = []  # list of all the networks that match the ip
        ip_split = ip.split('.')

        i = 0
        ports_list = list(self.table_disaggregated.keys())
        while i < len(ports_list):
            networks_of_port_list = self.table_disaggregated[ports_list[i]]
            j = 0
            while j < len(networks_of_port_list):
                # apply the mask
                current_netmask = networks_of_port_list[j]['netmask'].split('.')
                dest_masked = [int(ip_split[index]) & int(current_netmask[index]) for index in range(4)]
                src_masked = [int(networks_of_port_list[j]['network'].split('.')[index]) & int(current_netmask[index]) for index in range(4)]
                # compare with the given network
                k = 0
                flag = True
                # Solo dejar la flag aqui y en los demas siempre correrlo, entonces al final coger
                # el que mas largo tenga parecido
                while flag and k < 4:
                    if dest_masked[k] != src_masked[k]:
                        flag = False
                    k += 1

                if flag:
                    network_matches.append(networks_of_port_list[j])

                j += 1
            i += 1
        return network_matches

    def data_send(self, ip, type_msg, src, dst, msg):
        """Check if we can send the data based on their relationship"""
        if ip and (self.relations[self.ports_original[self.search_port(src)]] == 'cust' or self.relations[ip] == 'cust'):
            self.send(ip, json.dumps({"type": type_msg, "src": src, "dst": dst, "msg": msg}))
        else:
            # search the port that contains the source, to send the message back
            src_port = self.search_port(src)
            src = self.our_addr(self.ports_original[src_port])

            self.send(self.ports_original[src_port], json.dumps({"type": "no route", "src": src, "dst": dst, "msg": {}}))

    def data(self, msg_dic):
        """Check if there is a route and where to send the received data"""
        # print(self.table_original)

        # get the port associated with the IP of the destination
        dest_networks = self.search_networks(msg_dic['dst'])

        # print("DEST_PORT", dest_networks)

        # -----------
        # trivial case: no route
        # -----------
        if len(dest_networks) == 0:  # port not found
            self.data_send( None, "no route", None, msg_dic['src'], {})

        # -----------
        # trivial case: one destination found
        # -----------
        elif len(dest_networks) == 1:  # port found
            # forward the original message to the right destination
            self.data_send(dest_networks[0]['peer'],
                           "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])

        # -----------
        # non trivial case: choose the best "matching" network
        # -----------
        else:
            # first: get the longest subnet mask
            networks_longest_prefix = []

            maxim = 0
            for network in dest_networks:
                a = int(network['network'].replace('.', ''))
                if a > maxim:
                    networks_longest_prefix = [network]
                    maxim = a
                elif a == maxim:
                    networks_longest_prefix.append(network)

            # print('NETWORKS LONGEST PREFIX', networks_longest_prefix)

            if len(networks_longest_prefix) == 1:
                # forward the original message to the right destination
                self.data_send(networks_longest_prefix[0]['peer'],
                               "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])

            else:  # tie in the longest prefix
                # 1st: check the highest local pref
                networks_highest_pref = []
                maxim = 0
                for network in networks_longest_prefix:

                    a = network['localpref']
                    if a > maxim:
                        networks_highest_pref = [network]
                        maxim = a
                    elif a == maxim:
                        networks_highest_pref.append(network)
                    # print('NETWORKS HIGHEST PREFIX', networks_highest_pref)

                if len(networks_highest_pref) == 1:
                    # forward the original message to the right destination
                    self.data_send(networks_highest_pref[0]['peer'],
                                   "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])

                else:
                    # 2nd: check selfOrigin
                    networks_selforigin = networks_highest_pref
                    for network in networks_selforigin:
                        if not network['selfOrigin']:
                            networks_selforigin.remove(network)

                    # print('NETWORKS HIGHE PREFIX', networks_longest_prefix)
                    # In case all networks have selfOrigin = False restore the original list
                    if len(networks_selforigin) == 0:
                        networks_selforigin = networks_highest_pref

                    if len(networks_selforigin) == 1:
                        self.data_send(networks_selforigin[0]['peer'],
                                       "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])

                    else:
                        # 3rd: check ASpath
                        networks_shortest_ASPath = []
                        minim = len(networks_selforigin[0]['ASPath'])
                        for network in networks_selforigin:
                            a = len(network['ASPath'])
                            if a < minim:
                                networks_shortest_ASPath = [network]
                                minim = a
                            elif a == minim:
                                networks_shortest_ASPath.append(network)

                        # print('NETWORKS SHORTEST AS', networks_shortest_ASPath)

                        if len(networks_shortest_ASPath) == 1:
                            self.data_send(networks_shortest_ASPath[0]['peer'],
                                           "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])
                        else:
                            # 4th: check origin
                            igp, egp, unk = [], [], []
                            for network in networks_shortest_ASPath:
                                if network['origin'] == 'IGP':
                                    igp.append(network)
                                elif network['origin'] == 'EGP':
                                    egp.append(network)
                                else:
                                    unk.append(network)

                            if len(igp) == 0 and len(egp) == 0:
                                final_candidates = unk
                            elif len(igp) == 0:
                                final_candidates = egp
                            else:
                                final_candidates = igp

                            # print('finals', final_candidates)

                            if len(final_candidates) == 1:
                                self.data_send(final_candidates[0]['peer'],
                                               "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])
                            else:
                                #  5th: check src
                                networks_lowest_src = []
                                mini = int(final_candidates[0]['peer'].replace('.', ''))
                                for network in final_candidates:
                                    a = int(network['peer'].replace('.', ''))
                                    if a < mini:
                                        networks_lowest_src = [network]
                                        mini = a
                                    elif a == mini:
                                        networks_lowest_src.append(network)

                                # print('lowest scr', networks_lowest_src)

                                # the problem statement ensures that there will be no ties at this point
                                self.data_send(networks_lowest_src[0]['peer'],
                                               "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])

    def dump(self, src):
        self.send(src,
                  json.dumps({"type": "table",
                              "src": self.our_addr(src),
                              "dst": src,
                              "msg": [x for sublist in self.table_aggregation.values() for x in sublist]}))
        # we need to forward a list just with the networks dict

    def withdraw(self, msg_dic):
        # save a copy of the revocation
        # TODO

        # delete the network in the forwarding table
        for net_original in self.table_disaggregated[self.ports[msg_dic['src']]]:
            for net_withdraw in msg_dic['msg']:
                if net_original['network'] == net_withdraw['network'] \
                        and net_original['netmask'] == net_withdraw['netmask']:
                    self.table_disaggregated[self.ports[msg_dic['src']]].remove(net_original)

        # update neighbors about the withdram
        self.update_neighbors(msg_dic, "withdraw", msg_dic['msg'])


    def update_neighbors(self, msg_dic, type, msg):
        for ip in self.relations:
            if ip != msg_dic['src']:  # Not updating the neighbor that has sent me the update
                # updating the neighbours depends on the relations
                if self.relations[msg_dic['src']] == 'cust' or self.relations[ip] == 'cust':
                    self.send(ip,
                              json.dumps({"type": type,
                                          "src": self.our_addr(ip),
                                          "dst": ip,
                                          "msg": msg}))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)  # k == message, addr == address where it gets it from
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                msg_dic = json.loads(msg)  # msg now is a python dictionary
                # print('-------------------------------------------')
                # print(msg_dic["type"])

                if msg_dic["type"] == "update":
                    self.update(msg_dic)

                elif msg_dic["type"] == "data":
                    self.data(msg_dic)

                elif msg_dic["type"] == "dump":
                    self.dump(msg_dic['src'])

                elif msg_dic["type"] == "withdraw":
                    self.withdraw(msg_dic)

                else:
                    print("Operation", msg_dic["type"], "not implemented yet")

                print("Received message '%s' from %s" % (msg, srcif))
        # return


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
