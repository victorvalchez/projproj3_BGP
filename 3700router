#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math


class Router:
    relations = {}
    sockets = {}
    ports = {}


    table_original = {} # table that contains all the updates, no aggregation applied
    table_aggregation = {}
    ports_original = {} # dict to identify the IP associated to each port
    ip_port_original = {} # dict to identify the port associated to each new IP

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)

        self.asn = asn
        for relationship in connections:
            # Neighbor == IP that ends with .2
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))

            self.ports[neighbor] = int(port)
            # TODO, replace this variable with 'peer' attribute
            self.ports_original[int(port)] = neighbor
            self.ip_port_original[neighbor] = int(port)

            self.relations[neighbor] = relation
            self.send(neighbor,
                      json.dumps({"type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}}))

            self.table_original[int(port)] = []

    def our_addr(self, dst):
        """Router IP address, takes the destination and changes the final 2 with a 1"""
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def update(self, msg_dic):
        # -----------
        # Save a copy of the announcement
        # -----------
        # TODO

        # -----------
        # update forwarding table
        # -----------
        port = self.ports[msg_dic['src']] #get the port from which we received the message

        self.table_original[port].append(msg_dic['msg']) #add the update with the port as the key
        self.table_original[port][-1]['peer'] = msg_dic['src'] # add peer information to the entry

        #update auxiliar dictionary
        self.ip_port_original[msg_dic['msg']['network']] = self.ports[msg_dic['src']]

        # -----------
        # send copies of the announcement
        # -----------
        for ip in self.relations:
            if ip != msg_dic['src']:  # Not updating the neighbor that has sent me the update
                # updating the neighbours depends on the relations
                if self.relations[msg_dic['src']] == 'cust' or self.relations[ip] == 'cust':
                    self.send(ip,
                              json.dumps({"type": "update",
                                          "src": self.our_addr(ip),
                                          "dst": ip,
                                          "msg": {
                                              "network": msg_dic['msg']['network'],
                                              "netmask": msg_dic['msg']['netmask'],
                                              "ASPath": [self.asn] + msg_dic['msg']['ASPath']
                                          }}))

        # -----------
        # check if aggregation
        # -----------
        #TODO


    def search_port(self, ip):
        port = -1
        ip_split = ip.split('.')

        i = 0
        ports_list = list(self.table_original.keys())
        flag = False
        while not flag and i < len(ports_list):
            networks_of_port_list = self.table_original[ports_list[i]]
            j = 0
            while not flag and j < len(networks_of_port_list):
                # apply the mask
                aux = networks_of_port_list[j]['netmask'].split('.')
                dest_masked = [int(ip_split[index]) & int(aux[index]) for index in range(4)]
                # compare with the given network
                k = 0
                flag = True
                # Solo dejar la flag aqui y en los demas siempre correrlo, entonces al final coger
                # el que mas largo tenga parecido
                while flag and k < 4:
                    if dest_masked[k] != int(networks_of_port_list[j]['network'].split('.')[k]):
                        flag = False
                    k += 1

                if flag:
                    port = ports_list[i]

                j += 1
            i += 1

        return port  # -1 if the port is not found

    def search_networks(self, ip):
        network_matches = [] # list of all the networks that match the ip
        ip_split = ip.split('.')

        i = 0
        ports_list = list(self.table_original.keys())
        while i < len(ports_list):
            networks_of_port_list = self.table_original[ports_list[i]]
            j = 0
            while j < len(networks_of_port_list):
                # apply the mask
                aux = networks_of_port_list[j]['netmask'].split('.')
                dest_masked = [int(ip_split[index]) & int(aux[index]) for index in range(4)]
                # compare with the given network
                k = 0
                flag = True
                # Solo dejar la flag aqui y en los demas siempre correrlo, entonces al final coger
                # el que mas largo tenga parecido
                while flag and k < 4:
                    if dest_masked[k] != int(networks_of_port_list[j]['network'].split('.')[k]):
                        flag = False
                    k += 1

                if flag:
                    network_matches.append(networks_of_port_list[j])

                j += 1
            i += 1
        return network_matches

    def data_send(self, ip, type, src, dst, msg):
        #if self.relations[msg_dic['src']] == 'cust' or self.relations[ip] == 'cust':
        if self.relations[self.ports_original[self.search_port(src)]]  and self.relations[ip] == 'cust':
            self.send(ip, json.dumps({"type": type, "src": src, "dst": dst, "msg": msg }))
        else:
            self.send(ip, json.dumps({"type": "no route", "src": src, "dst": dst, "msg": {} }))

    def data(self, msg_dic):
        print(self.table_original)

        #get the port associated with the IP of the destination
        dest_networks = self.search_networks(msg_dic['dst']) 

        print("DEST_PORT", dest_networks)

        # -----------
        # trivial case: no route
        # -----------
        if len(dest_networks) == 0:  # port not found
            # search the port that contains the source, to send the message back
            src_port = self.search_port(msg_dic['src'])

            self.data_send(self.ports_original[src_port], "no route", self.our_addr(self.ports_original[src_port]), msg_dic['src'], {})

        # -----------
        # trivial case: one destination found
        # -----------
        elif len(dest_networks) == 1:  # port found
            # forward the original message to the right destination
            self.data_send(self.ports_original[self.ip_port_original[dest_networks[0]['network']]], "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])
       
        # -----------
        # non trivial case: choose the best "matching" network
        # -----------
        else:
            # first of all: get the longest subnet mask
            networks_longest_prefix = []
           

            max = 0
            for network in dest_networks:
                a = int(network['network'].replace('.', ''))
                if a > max: 
                    networks_longest_prefix = [ network ]
                    max = a
                elif a == max:
                    networks_longest_prefix.append(network)

            print('NETWORKS LOnGEST PREFIX', networks_longest_prefix)

            if len(networks_longest_prefix) == 1 :
                # forward the original message to the right destination
                self.data_send(self.ports_original[self.ip_port_original[networks_longest_prefix[0]['network']]], "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])

            else: 
                # tie in the longest prefix

                #check the highest local pref
                networks_highest_pref = []
                max = 0
                for network in networks_longest_prefix:
                    
                    a = network['localpref']
                    if a > max: 
                        networks_highest_pref = [ network ]
                        max = a
                    elif a == max:
                        networks_highest_pref.append(network)

                if len(networks_highest_pref) == 1:
                    # forward the original message to the right destination

                    self.data_send(self.ports_original[self.ip_port_original[networks_highest_pref[0]['network']]], "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])
                else:
                    #check selfOrigin
                    for network in networks_highest_pref:
                        if not network['selfOrigin']:
                            networks_highest_pref.remove(network)

                    if len(networks_highest_pref) == 1:
                        self.data_send(self.ports_original[self.ip_port_original[networks_highest_pref[0]['network']]], "data", msg_dic['src'],msg_dic['dst'], msg_dic['msg'])
                    else:
                        #check ASpath
                        networks_shortest_ASPath = []
                        max = 0
                        for network in networks_highest_pref:
                            
                            a = len(network['ASPath'])
                            if a > max: 
                                networks_shortest_ASPath = [ network ]
                                max = a
                            elif a == max:
                                networks_shortest_ASPath.append(network)

                        if len(networks_shortest_ASPath) == 1:
                            self.data_send(self.ports_original[self.ip_port_original[networks_shortest_ASPath[0]['network']]],
                                             "data", msg_dic['src'], msg_dic['dst'], msg_dic['msg'])
                        else:
                            #check origin
                            igp, egp, unk = [], [], []
                            for network in networks_shortest_ASPath:
                                if network['origin'] == 'IGP':
                                    igp.append(network)
                                elif network['origin'] == 'EGP':
                                    egp.append(network)
                                else:
                                    unk.append(network)

                            if len(igp) == 0 and len(egp) == 0:
                                final_candidates = unk
                            elif len(igp) == 0:
                                final_candidates = egp
                            else:
                                final_candidates = igp

                            if len(final_candidates) == 1:
                                self.data_send(self.ports_original[self.ip_port_original[final_candidates[0]['network']]], "data",
                                                msg_dic['src'], msg_dic['dst'], msg_dic['msg'])
                            else:
                                #check src
                                networks_lowest_src = []
                                min = int(final_candidates[0]['peer'].replace('.', ''))
                                for network in final_candidates:
                                    a = int(network['peer'].replace('.', ''))
                                    if a < min: 
                                        networks_lowest_src = [ network ]
                                        min = a
                                    elif a == min:
                                        networks_lowest_src.append(network)

                                #the problem statement ensures that there will be no ties at this point


                                self.data_send(self.ports_original[self.ip_port_original[networks_lowest_src[0]['network']]], "data", msg_dic['src'],
                                                msg_dic['dst'], msg_dic['msg'])


                                






    def dump(self, src):
        self.send(src,
                  json.dumps({"type": "table",
                              "src": self.our_addr(src),
                              "dst": src,
                              "msg": [x for sublist in self.table_original.values() for x in sublist]})) 
                              # we need to forward a list just with the networks dict

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)  # k == message, addr == address where it gets it from
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                msg_dic = json.loads(msg)  # msg now is a python dictionary
                print('-------------------------------------------')
                print(msg_dic["type"])

                if msg_dic["type"] == "update":
                    self.update(msg_dic)

                elif msg_dic["type"] == "data":
                    self.data(msg_dic)

                elif msg_dic["type"] == "dump":
                    self.dump(msg_dic['src'])

                else:
                    print("Operation", msg_dic["type"], "not implemented yet")

                print("Received message '%s' from %s" % (msg, srcif))
        # return


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
